# Godot Story: Equipment Matrix UI & Constraints

**Epic:** Equipment Matrix & Progression  
**Story ID:** 3.1  
**Priority:** High  
**Points:** 13  
**Status:** Approved  
**Language:** GDScript (with optional C# helper for grid packing if needed)  
**Performance Target:** 60+ FPS

## Description
Implement the grid-based equipment matrix allowing drag-and-drop placement of gear with shape constraints, rotation, burden tracking, and quick-remove actions. Build the HUD panel that integrates with dice slots and supports accessibility requirements. References: PRD story (docs/game-prd.md:284-300) and architecture sections on EquipmentController, UI component system (docs/architecture.md:120-260, 300-380).

**Godot Implementation:** Using `EquipmentController` Control scene, typed GDScript for drag/drop logic, and optional C# helper for packing heuristics if profiling demands  
**Performance Impact:** Medium; drag interactions and overlap checks must remain responsive (<150 ms), UI should pool tooltip/feedback elements to avoid GC spikes

## Acceptance Criteria
### Functional Requirements
- [ ] Equipment matrix grid supports placing/removing rotating items of varying shapes (L, 2x1, etc.)
- [ ] Invalid placements prevented with visual/audio feedback; valid placements update burden totals
- [ ] Equipped items can bind to dice slots or passives per resource metadata
- [ ] UI exposes quick-remove option without interrupting combat flow

### Technical Requirements
- Code follows GDScript/C# best practices with static typing
- Maintains 60+ FPS on all target devices (frame time <16.67ms)
- Object pooling implemented for spawned entities
- Signals properly connected and cleaned up
- GUT/GoDotTest coverage >= 80%
- [ ] Drag/drop overlap checks execute under 0.8ms; feedback elements pooled

### Game Design Requirements
- [ ] Matrix supports tactical loadout planning as described in PRD (docs/game-prd.md:40-95, 284-300)
- [ ] Feedback communicates burden and slot bindings clearly for mobile
- [ ] Accessibility (text scaling, color palette) supported by Control layout

## Technical Specifications
### Files to Create/Modify
**New Scenes (.tscn):**

- `res://scenes/ui/equipment_matrix.tscn` - Grid Control containing slot cells and drop targets
- `res://scenes/ui/equipment_item_card.tscn` - Visual representation for gear pieces
- `res://scenes/ui/equipment_inventory_panel.tscn` - Panel embedding matrix, item list, burden meter

**New Scripts:**

- `res://scripts/ui/equipment_controller.gd` - Core drag/drop, placement validation, burden tracking
- `res://scripts/ui/equipment_item_card.gd` - Handles rotation, tooltip display, dice binding preview
- `res://scripts/gameplay/equipment_inventory_model.gd` - Autoload or singleton tracking equipped items, linking to dice costs
- `res://scripts/ui/equipment_feedback_service.gd` - Pools error/success cues (haptics/audio)
- Optional: `res://scripts/utils/grid_packer.cs` - C# helper to optimize packing if required

**New Resources (.tres):**

- `res://resources/equipment/module_*.tres` - Gear definitions with shape mask, dice costs, effects
- `res://resources/config/equipment_matrix.tres` - Grid dimensions, base burden, dice slot bindings

**Modified Files:**

- `res://scenes/core/run_hud.tscn` - Add equipment panel to layout
- `res://scripts/autoload/resource_ledger.gd` - Interface with burden/slot updates if necessary
- `res://scripts/autoload/turn_manager.gd` - Recognize gear activation requests

### Node/Class Definitions
**GDScript Implementation (for game logic):**
```gdscript
# equipment_controller.gd
class_name EquipmentController
extends Control

@export var grid_width: int = 6
@export var grid_height: int = 4

var _cells: PackedVector2Array
var _placed_items: Array[EquipmentInstance] = []

signal gear_equipped(module: EquipmentModuleResource)
signal gear_removed(module: EquipmentModuleResource)

func try_place_item(instance: EquipmentInstance, origin_cell: Vector2i) -> bool:
    if not _fits(instance, origin_cell):
        equipment_feedback_service.show_invalid_feedback(origin_cell)
        return false
    _commit_item(instance, origin_cell)
    return true
```

**C# Implementation (for performance-critical systems):**
```csharp
// grid_packer.cs (optional)
[GlobalClass]
public partial class GridPacker : Node
{
    public bool Fits(bool[,] grid, bool[,] mask, Vector2I origin)
    {
        // No allocations, iterate with spans
        return true;
    }
}
```

### Integration Points
**Scene Tree Integration:**

- Parent Scene: `res://scenes/core/run_hud.tscn`
- Node Path: `/root/GameRoot/RunHUD/EquipmentPanel`
- Scene Instancing: Equipment panel instanced and connected to EquipmentInventoryModel

**Node Dependencies:**

- `EquipmentInventoryModel` (autoload) - stores equipped modules, exposes signals for dice costs
- `ResourceLedger` - updates burden or resource adjustments
- `TurnManager` - triggers module activations
- `TelemetryHub` - logs loadout changes

**Signal Connections:**

- Emits: `gear_equipped`, `gear_removed`, `gear_activated`
- Connects to: `EquipmentInventoryModel`, `TurnManager`, `TelemetryHub`
- Cleanup: Disconnect signals and return pooled cards in `_exit_tree()`

**Resource Dependencies:**

- `res://resources/equipment/module_*.tres` - gear definitions (preload async during loading screen)
- `res://resources/config/equipment_matrix.tres` - grid configuration (preload yes)

## TDD Workflow (Red-Green-Refactor)
**RED Phase - Write Failing Tests First:**

GDScript (GUT):
- [ ] Create `res://tests/unit/test_equipment_controller.gd` verifying placement logic
- [ ] Create `res://tests/unit/test_equipment_inventory_model.gd` verifying persistence/binding
- [ ] Performance test ensuring placement checks <0.8ms

C# (GoDotTest):
- [ ] If `GridPacker` used, create `res://tests/unit/GridPackerTests.cs` verifying fits logic and no allocations

**GREEN Phase - Make Tests Pass:**

- [ ] Implement grid placement, rotation, removal, burden updates
- [ ] Implement inventory model storing equipped modules with dice bindings
- [ ] Optimize placement checks (precomputed masks) to satisfy performance test
- [ ] Confirm tests pass in both languages (if C# helper used)

**REFACTOR Phase - Optimize and Clean:**

- [ ] Apply static typing to item lists, grid cells
- [ ] Pool equipment item cards and feedback cues
- [ ] Ensure cross-device drag thresholds tuned for mobile
- [ ] Validate performance with profiler while dragging multiple items
- [ ] Maintain >=80% coverage

## Implementation Tasks
**TDD Tasks (Red-Green-Refactor):**

- [ ] Write GUT tests for equipment controller and inventory model (plus GoDotTest if grid helper used)
- [ ] Implement matrix UI, placement validation, burden tracking to satisfy tests
- [ ] Refactor with typed structures, pooling, optional C# optimization
- [ ] Create object pool for equipment item cards and feedback effects
- [ ] Implement signal connections with inventory model, TurnManager, telemetry
- [ ] Profile performance to ensure 60+ FPS during drag/drop
- [ ] Language optimization (GDScript static typing, optional C# no-LINQ)
- [ ] Integration testing with ResourceLedger and dice tray bindings
- [ ] Final performance validation (60+ FPS)

**Debug Log:**
| Task | File | Change | Reverted? |
|------|------|--------|-----------|
| | | | |

**Completion Notes:**

**Change Log:**

## Godot Technical Context
**Engine Version:** Godot 4.5  
**Renderer:** Forward+  
**Primary Language:** GDScript (C# optional) - maintain single-language focus but allow micro-optimization

**Node Architecture:**
```
EquipmentPanel (Control)
├── MatrixGrid (GridContainer)
│   └── MatrixCell (Control) x N
├── ItemList (ScrollContainer)
└── BurdenMeter (Control)
```

**Performance Requirements:**
- Target FPS: 60+
- Frame Budget: 16.67ms
- Memory Budget: 450MB
- Draw Calls: <140 when matrix expanded

**Object Pooling Required:**
- Equipment item cards: pool size 12 (matching starting gear + stash)
- Feedback cues (audio/text): pool size 4

## Game Design Context
**GDD Reference:** Epic 3, Story 3.1 (docs/game-prd.md:284-292)

**Game Mechanic:** Resident Evil-style inventory puzzle enabling spatial loadout planning

**Godot Implementation Approach:**
- Node Architecture: Control nodes with drag/drop handling (docs/architecture.md:230-340)
- Language Choice: GDScript for core logic; optional C# helper if profiling indicates need
- Performance Target: Keep drag operations responsive and avoid UI stutter on mobile

**Player Experience Goal:** Deliver tactile, readable inventory management on touch devices with clear feedback.

**Balance Parameters (Resource-based):**

- Grid size, burden thresholds defined in `equipment_matrix.tres`
- Dice slot bindings per module stored in module resources

## Testing Requirements
### Unit Tests (TDD Mandatory)
**GUT Test Files (GDScript):**

- `res://tests/unit/test_equipment_controller.gd`
- `res://tests/unit/test_equipment_inventory_model.gd`
- Coverage Target: 80%

**GoDotTest Files (C#):**

- `res://tests/unit/GridPackerTests.cs` (only if helper used)

**Test Scenarios (Write First - Red Phase):**

- Placement fails when overlap occurs; success when valid - ensures integrity and performance
- Rotation updates mask boundaries correctly - signal verification
- Equipped gear updates dice binding signals and burden meter - boundary testing
- Performance test: drag/validate cycle <0.8ms processing cost

### Game Testing
**Manual Test Cases (Godot Editor):**

1. Drag varied shapes around matrix with rotation
   - Expected: Valid placements snap, invalid placements show feedback; burden meter updates
   - Performance: 60+ FPS maintained
   - Profiler: Frame time <16.67ms even during rapid dragging
   - Accessibility: Text scaling support verified

2. Equip item bound to dice slot and activate in combat
   - Expected: Dice tray highlights binding; activation consumes dice and triggers placeholder effect
   - Signal Flow: `gear_equipped` -> `TurnManager` -> `ResourceLedger` updates
   - Object Pools: Cards reused when removing/adding gear

### Performance Tests
**Godot Profiler Metrics (Mandatory):**

- Frame rate: 60+
- Frame time: <16.67ms average
- Physics frame: <2ms (UI heavy)
- Memory usage: <360MB with gear assets
- Draw calls: <140 when matrix visible
- Object pools: Item cards and feedback reusing properly
- GDScript static typing: Verified
- C# optimization: No LINQ/no allocations if helper used
- Drag validation CPU cost: <0.8ms

## Dependencies
**Story Dependencies:**

- 1.x: Dice loop and ResourceLedger foundation
- 2.x: Additional room equipment rewards coming later (3.2)

**Godot System Dependencies:**

- Node: RunHUD needs equipment panel placeholder
- Autoload: `EquipmentInventoryModel`, `TurnManager`, `ResourceLedger`, `TelemetryHub`
- Language: Typed GDScript baseline; optional C# integration pipeline ready

**Resource Dependencies:**

- Resource Type: `.tres`
- Asset: Module definitions, matrix config
- Location: `res://resources/equipment/`, `res://resources/config/`
- Import Settings: Text resources for diff-friendly editing

## Definition of Done
- All acceptance criteria met
- TDD followed (tests written first, then implementation)
- GUT tests passing (GDScript) with 80%+ coverage
- GoDotTest passing (C#) with 80%+ coverage (if helper used)
- Performance: 60+ FPS maintained on all platforms
- Static typing used in all GDScript
- C# optimized (no LINQ in hot paths) (if used)
- Object pooling active for spawned entities
- Signals properly connected and cleaned up
- No GDScript or C# errors/warnings
- Node hierarchy follows architecture
- Resources (.tres) configured properly
- Export templates tested
- Documentation updated
- UX reviewed for readability on mobile resolutions

## Notes
**Godot Implementation Notes:**

- Language Choice: GDScript primary; evaluate C# helper only if profiling indicates need
- Node Architecture: GridContainer ensures responsive layout with theme scaling
- Signal Pattern: Equipment controller communicates through inventory model and TurnManager
- Provide debug overlay for placement grid to aid QA and tuning

**Performance Decisions:**

- Static Typing: Use typed arrays for cells and equipment instances
- C# Usage: Optional micro-optimization; ensure no allocations if adopted
- Object Pooling: Gear cards, feedback cues, and tooltips pooled
- Avoid per-drag instantiation by reusing drag ghost nodes and highlight overlays
