# Godot Story: Prototype Room Queue & Exploration Actions

**Epic:** Crash Survivor Foundation  
**Story ID:** 1.3  
**Priority:** High  
**Points:** 8  
**Status:** Approved  
**Language:** GDScript  
**Performance Target:** 60+ FPS

## Description
Create the initial `RoomQueueService` autoload, data-driven room deck, and HUD interactions that present two active rooms plus backlog, handle action consumption, and replenish the queue from Resource-based definitions. Exploration choices must modify resources and threat according to card metadata. References: PRD story (docs/game-prd.md:170-186) and architecture sections (docs/architecture.md:110-220).

**Godot Implementation:** Using `RoomQueueService` autoload and Control-based card list with typed GDScript for data-driven queue management  
**Performance Impact:** Low-medium; queue operations must avoid allocation spikes and prefetch room data to keep frame times within budget

## Acceptance Criteria
### Functional Requirements
- [ ] Room queue displays two selectable rooms plus backlog count sourced from Resource data
- [ ] Selecting a room consumes an action, reveals detailed view, and queues replacement card
- [ ] Exploration outcome adjusts resources/threat per metadata (success/failure paths)
- [ ] Deck reshuffles when exhausted and prevents duplicate draws beyond defined limits

### Technical Requirements
- Code follows GDScript/C# best practices with static typing
- Maintains 60+ FPS on all target devices (frame time <16.67ms)
- Object pooling implemented for spawned entities
- Signals properly connected and cleaned up
- GUT/GoDotTest coverage >= 80%
- [ ] Room data loaded from `res://resources/rooms/*.tres` with caching and thread-safe refill strategy

### Game Design Requirements
- [ ] Room tags and difficulty reflect PRD archetypes (hazard/cache/sanctuary/anomaly)
- [ ] Action costs align with push-your-luck pacing described in PRD (docs/game-prd.md:40-95)
- [ ] Rewards adjust ResourceLedger values and contribute to clues/accessibility goals

## Technical Specifications
### Files to Create/Modify
**New Scenes (.tscn):**

- `res://scenes/ui/room_card.tscn` - Visual representation of a room card with interactions
- `res://scenes/ui/room_queue_panel.tscn` - Panel listing active rooms and backlog indicator

**New Scripts:**

- `res://scripts/autoload/room_queue_service.gd` - Autoload managing deck loading, shuffling, replenishment
- `res://scripts/ui/room_card_controller.gd` - Handles card taps, shows metadata, dispatches exploration requests
- `res://scripts/ui/room_queue_panel_controller.gd` - Binds queue data to UI and handles action gating
- `res://scripts/gameplay/exploration_resolver.gd` - Applies resource/threat outcomes post-selection

**New Resources (.tres):**

- `res://resources/rooms/deck_baseline.tres` - Defines baseline room cards and draw weights
- `res://resources/rooms/room_<slug>.tres` - Individual room definitions (12 baseline cards)

**Modified Files:**

- `res://scripts/autoload/turn_manager.gd` - Integrate room selection into turn phases
- `res://scenes/core/run_hud.tscn` - Add room queue panel and detail overlay placeholder

### Node/Class Definitions
**GDScript Implementation (for game logic):**
```gdscript
# room_queue_service.gd
class_name RoomQueueService
extends Node

@export var deck_resource: Resource

var _active_rooms: Array[RoomCardResource] = []
var _backlog: Array[RoomCardResource] = []

signal room_queue_updated(active_rooms: Array[RoomCardResource], backlog_size: int)

func _ready() -> void:
    _load_deck()
    _refill_active_rooms()
```

### Integration Points
**Scene Tree Integration:**

- Parent Scene: `res://scenes/core/run_hud.tscn`
- Node Path: `/root/GameRoot/RunHUD/RoomQueuePanel`
- Scene Instancing: RunHUD adds RoomQueue panel; RoomQueueService autoload accessible globally

**Node Dependencies:**

- `RoomQueueService` (autoload) - deck management (GDScript)
- `TurnManager` - consumes actions and requests room presentation (GDScript)
- `ResourceLedger` - receives adjustments from exploration resolver

**Signal Connections:**

- Emits: `room_queue_updated`, `room_selected`, `room_resolved`
- Connects to: Room queue panel UI and TurnManager for action gating
- Cleanup: Panel unsubscribes on `_exit_tree()`, service clears decks on new run start

**Resource Dependencies:**

- `res://resources/rooms/deck_baseline.tres` - baseline deck definitions (preload yes)
- `res://resources/config/game_balance.tres` - references for draw weights

## TDD Workflow (Red-Green-Refactor)
**RED Phase - Write Failing Tests First:**

GDScript (GUT):
- [ ] Create `res://tests/unit/test_room_queue_service.gd`
- [ ] Test deck loading and active slot refill logic - expect failure
- [ ] Test action consumption preventing double selection per turn - expect failure
- [ ] Performance test verifying queue update executes under 1ms - expect failure

C# (GoDotTest):
- Not required

**GREEN Phase - Make Tests Pass:**

- [ ] Implement deck load, shuffle, and active/backlog management
- [ ] Integrate TurnManager checks for action availability
- [ ] Optimize queue updates and caching to pass performance test
- [ ] Ensure all tests pass

**REFACTOR Phase - Optimize and Clean:**

- [ ] Add static typing across queue structures
- [ ] Use pooled room card instances to avoid Control instantiation cost
- [ ] Ensure signals cleaned up and deck resets handled gracefully
- [ ] Profile queue refresh with profiler to confirm <1ms spent
- [ ] Maintain >=80% coverage

## Implementation Tasks
**TDD Tasks (Red-Green-Refactor):**

- [ ] Write GUT tests for RoomQueueService deck operations
- [ ] Implement queue service, panel controllers, and exploration resolver to satisfy tests
- [ ] Refactor with typed arrays, caching, and pooling
- [ ] Create object pool for `room_card.tscn` instances
- [ ] Implement signal connections between TurnManager and RoomQueueService
- [ ] Profile performance to ensure 60+ FPS during queue updates
- [ ] Language optimization (GDScript static typing)
- [ ] Integration testing with ResourceLedger adjustments
- [ ] Final performance validation (60+ FPS)

**Debug Log:**
| Task | File | Change | Reverted? |
|------|------|--------|-----------|
| | | | |

**Completion Notes:**

**Change Log:**

## Godot Technical Context
**Engine Version:** Godot 4.5  
**Renderer:** Forward+  
**Primary Language:** GDScript - consistent with autoload/service architecture

**Node Architecture:**
```
RunHUD (Control)
└── RoomQueuePanel (Control)
    ├── ActiveRoomSlot1 (Control)
    ├── ActiveRoomSlot2 (Control)
    └── BacklogCounter (Label)
```

**Performance Requirements:**
- Target FPS: 60+
- Frame Budget: 16.67ms
- Memory Budget: 450MB
- Draw Calls: < 90 for HUD + room cards

**Object Pooling Required:**
- Room card UI nodes: Pool size 4 (two active + buffer)
- Event overlays: pool placeholders for future overlays (size 2)

## Game Design Context
**GDD Reference:** Epic 1, Story 1.3 (docs/game-prd.md:170-183)

**Game Mechanic:** Room queue management and exploration choices

**Godot Implementation Approach:**
- Node Architecture: Autoload manages Resource-based deck feeding Control panels (docs/architecture.md:190-230)
- Language Choice: GDScript ensures consistent data manipulation and signal flow
- Performance Target: Keep queue refresh under 1ms, maintain 60 FPS even during reshuffle

**Player Experience Goal:** Offer at-a-glance room choices and maintain tension by exposing limited information and costs.

**Balance Parameters (Resource-based):**

- Deck composition weights stored in `deck_baseline.tres`
- Room difficulty modifiers exported for designer tuning

## Testing Requirements
### Unit Tests (TDD Mandatory)
**GUT Test Files (GDScript):**

- `res://tests/unit/test_room_queue_service.gd`
- `res://tests/unit/test_exploration_resolver.gd`
- Coverage Target: 80%

**GoDotTest Files (C#):**

- N/A

**Test Scenarios (Write First - Red Phase):**

- Queue loads baseline deck and populates two active slots - ensures 60 FPS by preloading resources
- Selecting a room decrements action count and triggers replacement draw - signal verification
- Deck reshuffle respects composition limits and avoids duplication beyond defined tags - boundary testing
- Performance test: queue update under 1ms, frame time <16.67ms

### Game Testing
**Manual Test Cases (Godot Editor):**

1. Cycle through draws until deck reshuffle
   - Expected: Backlog counts update, no duplicate anomalies beyond limit
   - Performance: 60+ FPS maintained
   - Profiler: Frame time <16.67ms
   - Signals: `room_queue_updated` events observed once per change

2. Select room with success/failure outcomes
   - Expected: ResourceLedger adjusts values, threat meter responds per metadata
   - Signal Flow: `room_resolved` fires with results
   - Memory: Room cards reused via pooling
   - Object Pools: Instances reused without leaks

### Performance Tests
**Godot Profiler Metrics (Mandatory):**

- Frame rate: 60+
- Frame time: <16.67ms average
- Physics frame: <2ms (minimal involvement)
- Memory usage: <300MB including room assets
- Draw calls: <90 while cards visible
- Object pools: Room cards and overlays reused
- GDScript static typing: Verified
- C# optimization: N/A
- Queue update CPU cost: <0.6ms

## Dependencies
**Story Dependencies:**

- 1.1: Requires dice loop and TurnManager integration
- 1.2: Needs ResourceLedger for outcome adjustments

**Godot System Dependencies:**

- Node: RunHUD with RoomQueue panel placeholder
- Autoload: `RoomQueueService`, `TurnManager`, `ResourceLedger`
- Language: Typed GDScript pipeline

**Resource Dependencies:**

- Resource Type: `.tres`
- Asset: `deck_baseline.tres` and individual room card resources
- Location: `res://resources/rooms/`
- Import Settings: Keep as text resources for merge-friendly edits

## Definition of Done
- All acceptance criteria met
- TDD followed (tests written first, then implementation)
- GUT tests passing (GDScript) with 80%+ coverage
- GoDotTest passing (C#) with 80%+ coverage (N/A)
- Performance: 60+ FPS maintained on all platforms
- Static typing used in all GDScript
- C# optimized (no LINQ in hot paths) (N/A)
- Object pooling active for spawned entities
- Signals properly connected and cleaned up
- No GDScript or C# errors/warnings
- Node hierarchy follows architecture
- Resources (.tres) configured properly
- Export templates tested
- Documentation updated
- Room queue behavior reviewed for UX clarity on mobile

## Notes
**Godot Implementation Notes:**

- Language Choice: GDScript for consistent data-driven gameplay systems
- Node Architecture: Panel composition keeps queue flexible for future expansions
- Signal Pattern: Autoload emits typed updates to decouple UI from service
- Use `ResourceUID` references for cross-links to events/threats as defined in architecture

**Performance Decisions:**

- Static Typing: Arrays typed to `RoomCardResource`
- C# Usage: Deferred until profiling suggests need
- Object Pooling: Room card UI nodes pooled to eliminate Control allocations mid-run
- Prefetch room resources during boot to avoid hitches when presenting new cards
