# Godot Story: Advanced Room Decks & Events

**Epic:** Threat Escalation & Room Depth  
**Story ID:** 2.1  
**Priority:** High  
**Points:** 8  
**Status:** Approved  
**Language:** GDScript  
**Performance Target:** 60+ FPS

## Description
Expand the room content pipeline to support at least 30 unique room cards with archetype tags, event hooks, and configurable deck composition. Implement the narrative event resolver overlay that presents contextual choices altering resources/threat. References: PRD story (docs/game-prd.md:215-233) and architecture sections on Resource-driven content (docs/architecture.md:120-260).

**Godot Implementation:** Using Resource-authored `RoomCardResource` assets, `RoomQueueService` extension methods, and a reusable `EventResolver` Control scene in typed GDScript  
**Performance Impact:** Moderate; loading additional content must use streaming/batching to avoid frame spikes, event resolver overlays should reuse pooled UI elements

## Acceptance Criteria
### Functional Requirements
- [ ] Room deck expanded to >=30 cards with tags (hazard, cache, sanctuary, anomaly)
- [ ] Deck composition rules enforce tag limits (e.g., max 3 anomalies) and shuffle weights via config
- [ ] Selecting certain rooms triggers narrative event overlay with contextual choices and resource/threat impacts
- [ ] Event outcomes logged to combat log/telemetry stub for later balancing

### Technical Requirements
- Code follows GDScript/C# best practices with static typing
- Maintains 60+ FPS on all target devices (frame time <16.67ms)
- Object pooling implemented for spawned entities
- Signals properly connected and cleaned up
- GUT/GoDotTest coverage >= 80%
- [ ] Deck loading streams room resources asynchronously during downtime to minimize hitching

### Game Design Requirements
- [ ] Room archetypes align with PRD tags and deliver diversity in difficulty/reward (docs/game-prd.md:40-95, 215-233)
- [ ] Event choices reflect narrative tone and push risk/reward decision making
- [ ] Logs capture data required for balancing (resource deltas, threat escalation)

## Technical Specifications
### Files to Create/Modify
**New Scenes (.tscn):**

- `res://scenes/ui/event_resolver.tscn` - Overlay Control presenting narrative text, choices, and outcomes

**New Scripts:**

- `res://scripts/resources/room_card_resource.gd` - Resource script with metadata fields (if not existing)
- `res://scripts/ui/event_resolver_controller.gd` - Handles event presentation, choice callbacks, and logging
- `res://scripts/services/deck_rules_engine.gd` - Applies composition rules when building deck
- `res://scripts/services/event_log_service.gd` - Batches event outcomes for telemetry

**New Resources (.tres):**

- `res://resources/rooms/room_*.tres` - Additional room cards with metadata (tags, difficulty, events)
- `res://resources/config/deck_rules.tres` - Defines tag limits and weights
- `res://resources/events/event_*.tres` - Optional data assets for narrative events

**Modified Files:**

- `res://scripts/autoload/room_queue_service.gd` - Integrate deck rules engine and event triggers
- `res://scenes/ui/room_queue_panel.tscn` - Hook event overlay entry point

### Node/Class Definitions
**GDScript Implementation (for game logic):**
```gdscript
# deck_rules_engine.gd
class_name DeckRulesEngine
extends Resource

@export var max_anomaly_cards: int = 3
@export var tag_weights: Dictionary = {
    "hazard": 1.0,
    "cache": 0.8,
    "sanctuary": 0.7,
    "anomaly": 0.3
}

func compose_deck(source_cards: Array[RoomCardResource]) -> Array[RoomCardResource]:
    # Filter and weighted shuffle respecting tag limits
    return []
```

### Integration Points
**Scene Tree Integration:**

- Parent Scene: `res://scenes/core/run_hud.tscn`
- Node Path: `/root/GameRoot/RunHUD/EventResolver`
- Scene Instancing: Resolver overlay instanced as needed and reused via pooling

**Node Dependencies:**

- `RoomQueueService` - now references deck rules engine and event resolver
- `ResourceLedger` - updated based on event outcomes
- `TelemetryHub` - receives event log entries

**Signal Connections:**

- Emits: `event_presented`, `event_resolved`
- Connects to: `EventResolverController` for UI, `TelemetryHub` for logging, `RoomQueueService` for continuing flow
- Cleanup: Overlay unsubscribes on `_exit_tree()`, event logs flushed post-run

**Resource Dependencies:**

- `res://resources/config/deck_rules.tres` - deck composition configuration (preload yes)
- `res://resources/events/event_catalog.tres` - optional event linking file (preload yes)

## TDD Workflow (Red-Green-Refactor)
**RED Phase - Write Failing Tests First:**

GDScript (GUT):
- [ ] Create `res://tests/unit/test_deck_rules_engine.gd`
- [ ] Test deck composition obeys tag limits and weights - expect failure
- [ ] Create `res://tests/unit/test_event_resolver_controller.gd` verifying choices adjust resources - expect failure
- [ ] Performance test ensuring deck rebuild executes <1.5ms - expect failure

C# (GoDotTest):
- Not required

**GREEN Phase - Make Tests Pass:**

- [ ] Implement deck rules weighting and selection logic
- [ ] Implement event resolver applying outcomes with ResourceLedger integration
- [ ] Optimize deck rebuild (precompute arrays, caching) to pass performance test
- [ ] Ensure tests green

**REFACTOR Phase - Optimize and Clean:**

- [ ] Add static typing across deck/event components
- [ ] Pool event overlay instances and text nodes
- [ ] Preload event data during boot to avoid run-time loads
- [ ] Ensure logs flush efficiently without blocking main thread
- [ ] Maintain coverage >=80%

## Implementation Tasks
**TDD Tasks (Red-Green-Refactor):**

- [ ] Write GUT tests for deck rules and event resolver
- [ ] Implement deck composition, event overlay, and logging to satisfy tests
- [ ] Refactor with typed arrays, caching, pooling
- [ ] Create object pool for event overlay nodes
- [ ] Implement signal connections linking RoomQueueService to EventResolver and TelemetryHub
- [ ] Profile performance (deck rebuild/event overlay) to ensure 60 FPS
- [ ] Language optimization (GDScript static typing)
- [ ] Integration testing with RoomQueueService and ResourceLedger
- [ ] Final performance validation (60+ FPS)

**Debug Log:**
| Task | File | Change | Reverted? |
|------|------|--------|-----------|
| | | | |

**Completion Notes:**

**Change Log:**

## Godot Technical Context
**Engine Version:** Godot 4.5  
**Renderer:** Forward+  
**Primary Language:** GDScript - maintains single-language pipeline for deck/event systems

**Node Architecture:**
```
RunHUD (Control)
└── EventResolver (CanvasLayer)
    ├── NarrativeText (RichTextLabel)
    ├── ChoiceList (VBoxContainer)
    └── OutcomePreview (Control)
```

**Performance Requirements:**
- Target FPS: 60+
- Frame Budget: 16.67ms
- Memory Budget: 450MB
- Draw Calls: <115 when resolver overlay active

**Object Pooling Required:**
- Event choice buttons: pool size 4
- Overlay instances: single pooled CanvasLayer reused per event

## Game Design Context
**GDD Reference:** Epic 2, Story 2.1 (docs/game-prd.md:215-223)

**Game Mechanic:** Room diversity with narrative events influencing resources/threat

**Godot Implementation Approach:**
- Node Architecture: Resource-driven deck feeding event overlays (docs/architecture.md:190-280)
- Language Choice: GDScript for resource parsing and UI integration
- Performance Target: Precompute deck composition during downtime to maintain 60 FPS

**Player Experience Goal:** Deliver variety and narrative flavor, reinforcing push-your-luck by offering meaningful event choices.

**Balance Parameters (Resource-based):**

- Tag weights defined in `deck_rules.tres`
- Event outcome modifiers stored per event resource

## Testing Requirements
### Unit Tests (TDD Mandatory)
**GUT Test Files (GDScript):**

- `res://tests/unit/test_deck_rules_engine.gd`
- `res://tests/unit/test_event_resolver_controller.gd`
- Coverage Target: 80%

**GoDotTest Files (C#):**

- N/A

**Test Scenarios (Write First - Red Phase):**

- Deck build respects anomaly cap and weight distribution - ensures consistent performance via precompute
- Event selection applies correct ResourceLedger deltas - signal verification
- Event logging batches entries without duplicates - ensures log boundary correctness
- Performance test: deck rebuild <1.5ms, overlay show/hide <0.8ms

### Game Testing
**Manual Test Cases (Godot Editor):**

1. Trigger multiple event-bearing rooms
   - Expected: Overlay shows narrative text and options; choices update resources/threat and log events
   - Performance: 60+ FPS maintained
   - Profiler: Frame time <16.67ms
   - Signals: `event_resolved` fired once per event

2. Exhaust deck and ensure reshuffle respects composition
   - Expected: Tag limits maintained, weight distribution roughly applied
   - Memory: Room resources reused without leak
   - Object Pools: Event overlay reused

### Performance Tests
**Godot Profiler Metrics (Mandatory):**

- Frame rate: 60+
- Frame time: <16.67ms average
- Physics frame: <2ms
- Memory usage: <340MB with expanded room assets
- Draw calls: <115 with overlay active
- Object pools: Buttons/overlays reused
- GDScript static typing: Verified
- C# optimization: N/A
- Deck rebuild CPU cost: <1.5ms

## Dependencies
**Story Dependencies:**

- 1.3: Extends existing room queue infrastructure

**Godot System Dependencies:**

- Node: Room queue panel and event overlay placeholders from prior stories
- Autoload: `RoomQueueService`, `TelemetryHub`, `ResourceLedger`
- Language: Typed GDScript environment

**Resource Dependencies:**

- Resource Type: `.tres`
- Asset: New room cards, event resources, deck rules
- Location: `res://resources/rooms/`, `res://resources/events/`
- Import Settings: Use text resources for version control friendliness

## Definition of Done
- All acceptance criteria met
- TDD followed (tests written first, then implementation)
- GUT tests passing (GDScript) with 80%+ coverage
- GoDotTest passing (C#) with 80%+ coverage (N/A)
- Performance: 60+ FPS maintained on all platforms
- Static typing used in all GDScript
- C# optimized (no LINQ in hot paths) (N/A)
- Object pooling active for spawned entities
- Signals properly connected and cleaned up
- No GDScript or C# errors/warnings
- Node hierarchy follows architecture
- Resources (.tres) configured properly
- Export templates tested
- Documentation updated
- Event analytics integrated with telemetry stub

## Notes
**Godot Implementation Notes:**

- Language Choice: GDScript maintains unified content tooling
- Node Architecture: Overlay reuse prevents UI duplication
- Signal Pattern: RoomQueueService orchestrates events, TelemetryHub logs outcomes
- Deck rule engine should expose inspector-friendly exports for designers

**Performance Decisions:**

- Static Typing: Arrays typed as `RoomCardResource` and `EventResource`
- C# Usage: Not required; GDScript meets needs
- Object Pooling: Event overlay nodes pooled for reuse
- Preload heavy narrative text to avoid loading jank mid-run
